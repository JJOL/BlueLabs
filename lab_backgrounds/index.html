<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<link href="https://fonts.googleapis.com/css?family=Roboto:400,700" rel="stylesheet">
	<link rel="stylesheet" type="text/css" href="main.css">
	<link rel="stylesheet" type="text/css" href="lstyle.css">
	<title>BlueLabs - Backgrounds</title>
</head>
<body>

	<main>
		<div class="chapter" id="ch-0">
			<div class="cover-menu">
				<ol>
					<li><a href="#ch-1">Blue-Labs Inc.</a></li>
					<li><a href="#ch-2">Greetings</a></li>
					<li><a href="#ch-3">Task Introduction</a></li>
					<li><a href="#ch-4">Task Description</a></li>
					<li><a href="#ch-5">References & Resources</a></li>
					<li><a href="#ch-6">Good Luck</a></li>
				</ol>
			</div>
			<div class="cover-title"><h1>Back-<br>Grounds</h1></div>
		</div>

		<div class="chapter" id="ch-1">
			<div class="ch-img ch-img-full">
				<div class="ch-caption">Blue-Labs Inc.</div>
			</div>
		</div>

		<div class="chapter" id="ch-2">
			<div class="ch-img ch-img-small">
				<div class="ch-caption">Greetings.</div>
				<div id="ch-3-secretary"></div>
			</div>
			<div class="ch-dialog">
				<p>Bienvenido a Blue-Labs Inc. Una compañia falsa del Instituto Tecnológico de Estudios Superiores de Monterrey Campus QRO que se dedica a desarrollar proyectos falsos relacionados a software de videojuegos!</p>
				<p>Tu debes ser el nuevo recluta, no? El te estaba esperando pero ahorita esta ocupado en una reunión con un cliente exigente.</p>
				<p>Por favor esperalo hasta pasar a la siguiente viñeta.</p>
			</div>
		</div>

		<div class="chapter" id="ch-3">
			<div class="ch-img ch-img-small">
				<div class="ch-caption">Task Introduction.</div>
				<div id="ch-3-secretary"></div>
				<div id="ch-3-boss"></div>
			</div>
			<div class="ch-dialog">
				<p>¡Raúl! ¿En dónde esta el nuevo trabajor y próximo Chief Technology Officer? <em>Esta en frente de usted señor...</em> Ah! Magnífico!</p>
				<p>Que bueno que llegaste. El puesto de CTO va para ser tuyo pero primero tendrás que realizar unos cuantas tareas.</p>
				<p>Comenzando por este que nos solicito el representante de Freev, una gigante tecnológica desarrolladora de millones de juegos. Desafortunadamente se especializan en desarrollo web por lo que nos estan pidiendo ayuda con la implementación de un sistema de fondos scrolleables para su próximo lanzamiento en computadora.</p>
			</div>
		</div>

		<div class="chapter" id="ch-4">
			<h3>Task Information</h3>
			<div class="project-description">
				<h1 class="proj-name">A1-Background</h1>
				<div class="proj-contents-holder">
					<div class="proj-content" id="pc-1">
						<h2 class="proj-sub-title">Descripcion</h2>
						<p class="proj-sub-description">'A1-Background' es un prototipo para probar ante el cliente diferentes técnicas para implementar 'background-scrolling' en un videojuego desarrollado en el lenguaje Java con un conecpto prototipo del jugador y una cantidad mínima de enemigos.</p><br>
						<p>Se espera la entrega para el día: Miércoles 27 de Febrero del 2019</p>
						<img class="proj-front-img" id="proj-1-final" src="assets/project_cover.png" width="230">
					</div>
					<div class="proj-content" id="pc-2">
						<h2 class="proj-sub-title">Estructura</h2>
						<div style="width: 49%; display: inline-block;">
							<h3><em>Estructura de Partida</em></h3>
							<p class="proj-sub-description">La estructura de donde partimos el proyecto es el esqueleto del juego desarrollado en las clases previas.</p>

							<img src="assets/project_old_structure.png" width="100%">
						</div>
						<div style="width: 49%; display: inline-block;">
							<h3><em>Estructura Nuevo</em></h3>
							<p class="proj-sub-description">Remplazaremos el módulo ManyBalls por un diseño arquitectónico ya desarrollado aquí en BlueLabs</p>

							<img src="assets/proj_structure.png" width="100%">
						</div>
					</div>
					<div class="proj-content" id="pc-3">
						<h2 class="proj-sub-title">LevelController</h2>
						<p class="proj-sub-description">La clase LevelController nos va a servir para agrupar 2 implementaciones diferentes de nuestro 'Background Scrolling' bajo un mismo concepto. De esta manera podemos declarar una variable de tipo LevelController en GamePanel para guardar la instancia de cualquiera de las 2 subclases, y así, hacer pruebas.</p>
						<br>
						<img src="assets/detail_uml.jpg" width="300" height="200">
					</div>
					<div class="proj-content" id="pc-4">
						<h2 class="proj-sub-title">Paso 1: Empezar Proyecto</h2>
						<p class="proj-sub-description">Prepara un proyecto con la estructura mencionada anteriormente. Para esto puedes hacer una copia de las clases pasadas como GamePanel y hacer las siguientes modificaciones:</p>
						<br>
						<ol style="width: 80%; padding-left: 20px">
							<li>Remueve las clases ManyBalls y Ball.</li>
							<li>En GamePanel remueve las variable tipo ManyBalls y todo lo relacionado a ella.</li>
							<li>Crea una clase llamada LevelController con un método público void update() y un método público void render(Graphics2D g).</li>
							<li>Crea las 2 clases FakeScrollLevel y CameraScrollLevel que hereden de LevelController con las variables que se muestra en el UML y el los constructores llamando a super().</li>
							<li>En GamePanel crea una variable privada tipo LevelController llamado <em>level</em>. En el constructor de GamePanel asigna a level una nueva instancia de la clase FakeScrollLevel() pasando PWIDTH y PHEIGHT como parametros al constructor de FakeScrollLevel. En gameRender() ejecuta <em>level.render((Graphics2D)dbg)</em> después del pintado del fondo. En gameUpdate() ejecuta <em>level.update()</em>.</li>
						</ol>
						
					</div>

					<div class="proj-content" id="pc-5">
						<h2 class="proj-sub-title">Scrolling Backgrounds</h2>
						<p class="proj-sub-description">Hacer un 'scrolling background' es dar la ilusión visual al jugador de un fondo en el videojuego que va avanzando. Este es un efecto muy poderoso en videojuegos ya que crea una sensación de movimiento espacial adentro del juego.</p>
						<p>IMPORTANCIA: Si en un juego con un mundo virtual relativamente grande, (mayor a la pantalla), no se presenta este efecto, puede ocasionar que el jugador se pierda fácilmente ya que no tendrá un punto de referencia para ubicarse. También puede usarse para indicar progreso a través de los niveles dejando claro al jugador que esta haciendo lo correcto.</p>
						<br>
						<br>
						<p>Veremos 2 maneras de implementar este efecto. La primera, probablemente familiar, consiste en simularlo dibujando 2 veces el fondo para crear un bucle. La segunda, dibujamos un mundo mucho más amplio que la pantalla, y hacemos que la 'cámara' de la pantalla se vaya moviendo en nuestro mundo.</p>
						<p>Ambas técnicas tienen ventajas y deventajas que se verán a continuación.</p>
						
					</div>

					<div class="proj-content" id="pc-6">
						<h2 class="proj-sub-title">Fake Scrolling</h2>
						<p class="proj-sub-description">Como se muestra en la imagen, en esta técnica se dibuja 2 veces el fondo en diferentes posiciones. Llamemos a estas posiciones <em>back1_x</em> y <em>back2_x</em>. La idea es que la segunda imagen siempre esté por detrás de la primera, y de la misma forma, la primera esté por detrás de la segunda, mientras ambas avanzan con la misma velocidad. Esto crea un bucle infinito del fondo ya que cuando termina una imagen, la otra le sigue inmediatamente dando la ilusión que es el mismo fondo.</p>
						<img src="assets/fake_scroll_mechanic.jpg" width="400">
						
					</div>
					<div class="proj-content" id="pc-7">
						<h2 class="proj-sub-title">Fake Scrolling - Implementación</h2>
						<p class="proj-sub-description">Para implementarlo usaremos las variables de la clase FakeScrollingLevel. Primero en el <em>constructor</em> tenemos que cargar nuestra imagen usando el metodo <em>read()</em> de ImageIO de la siguiente manera:</p>
						<code style="background-color: white; color: blue">
							try {<br>
								&emsp;img = (BufferedImage)ImageIO.read(<br>&emsp;getClass().getClassLoader().getResource("./sback.png"));<br>
							} catch (IOException e) {<br>
								&emsp;// TODO Auto-generated catch block <br>
								&emsp;e.printStackTrace();<br>
							}
						</code>
						<p>Después inicializamos nuestras variables b1_xOff=0 y b2_xOff=b1_xOff+img.getWidth(). Esto es para que el comienzo del segundo fondo este inmediatamente después del final del primero.</p>
						
					</div>
					<div class="proj-content" id="pc-8">
						<h2 class="proj-sub-title">Fake Scrolling - Implementación</h2>
						<p>En <em>render(Graphics2D g)</em> sólo necesitamos dibujar 2 veces nuestro fondo usando el método <em>drawImage(img, x, y, null)</em> de Graphics. Aquí primero llamamos drawImage() con nuestra variable b1_xOff para x, y después llamamos de nuevo drawImage() pero con la variable b2_xOff en vez.</p>
						<br>
						<p>Por último, en <em>update()</em> primero movemos los offsets restandole a cada uno el valor de 5 para que se 'muevan' 5 pixeles a la izquierda. Después hay que checar si tenemos que colocar nuestro fondo en el comienzo de nuevo. Para esto en un if probamos si nuestro b1_xOff es menor o igual que - img.getWidth(), si se cumple la condición, entonces decimos que b1_xOff = img.getWidth(). Y hacemos un if similar para b2_xOff separado.</p>

						<br>
						<p>Ya con eso solo nos queda probar dandole click en 'Run'!</p>
						
					</div>
					<div class="proj-content" id="pc-9">
						<h2 class="proj-sub-title">Fake Scrolling - Usos</h2>
						
						<p>Esta es una buena técnica para usar en juegos en donde los niveles son auto generados dinámicamente. Esto quiere decir que los elementos del juego como obstaculo o enemigos van 'apareciendo' a través del tiempo conforme el jugador juega. En este tipo de juegos los elementos generalmente no estan relacionados directamente con el fondo y su posición actual por lo que esta sencilla técnica, o alguna adaptación de ella, puede usarse sin problema. Además, es muy eficiente en cuanto a rendimiento ya que sólo tiene que siempre 2 copias del fondo.</p>
						<br>
						<p>Sin embargo, si se desea que el fondo se desplazca horizontal y verticalmente, puede ser más complicado de lo necesario. También si tienes un mapa grande bien definido con elementos estáticos o autónomos en varios puntos del mapa, tendrás que definir un sistema de coordenadas para que puedas renderizarlos trasladando sus posiciones respecto a donde se haya movido el jugador. Esto es mucha talacha en el código y además crea muchas dependencias innecesarias entre diferentes clases. Y recuerda que siempre hay que buscar reducir el acoplamiento entre clases para hacer más sencillo de entender y probar el software.</p>
						
					</div>

					<div class="proj-content" id="pc-10">
						<h2 class="proj-sub-title">Camera Scrolling</h2>
						<p class="proj-sub-description">Esta técnica consiste en dibujar todo el mundo completo tal como está y en donde está, y dejar más bien que la 'cámara' de la aplicación se mueva. De esta manera podemos por ejemplo dibujar multiples fondos fijos, uno después del otro, siempre en un mismo lugar.</p>
						<p>En el juego primero se va a observar el primer fondo y conforme la camara vaya moviendo, se irán mostrando los siguientes o previos fondos.</p>
						<img src="assets/camera_scroll_overview.png" width="400">
						
					</div>
					<div class="proj-content" id="pc-11">
						<h2 class="proj-sub-title">Camera Scrolling - Implementación</h2>
						<p class="proj-sub-description">Para implementarlo usaremos las variables de la clase CameraScrollingLevel. Primero en el <em>constructor</em> tenemos que cargar nuevamente nuestra imagen usando el metodo <em>read()</em> de ImageIO de la siguiente manera:</p>
						<code style="background-color: white; color: blue">
							try {<br>
								&emsp;img = (BufferedImage)ImageIO.read(<br>&emsp;getClass().getClassLoader().getResource("./sback.png"));<br>
							} catch (IOException e) {<br>
								&emsp;// TODO Auto-generated catch block <br>
								&emsp;e.printStackTrace();<br>
							}
						</code>
						<p>Después inicializamos nuestra variable de posición camX = 0. Y definimos la cantidad fondos que queremos repetir en nuestro mundo, por ejemplo nBacks = 8.</p>
						
					</div>
					<div class="proj-content" id="pc-12">
						<h2 class="proj-sub-title">Camera Scrolling - Implementación</h2>
						<p>En <em>render(Graphics2D g)</em> ahora dibujaremos nuestra imagen dentro de un for i=0 a nBacks, y en cada iteración ejecutamos <em>g.drawImage(img, i*img.getWidth(), 0, null);</em> para se dibujen los 8 fondos cada uno después del previo.
						</p>
						<p>Tambíen será necesario en <em>render()</em> simular nuestra camara y esto lo haremos con el método <em>tanslate(x,y)</em> de Graphics. Este método mueve todo el sistema de coordenadas que se utiliza para renderizar gráficos por lo que cuando hacemos <em>g.translate(-camX, 0);</em> es como si todo el plano se haya desplazado y el origen se ubique en camX. </p>
						<br>
						<p>Finalmente, en <em>update()</em> tenemos que mover hacia adelante nuestra cámara sumandole a camX el valor 5, para que se mueva 5 pixeles hacia en frente.</p>

						<br>
						<p>Ya con eso solo nos queda probar cambiando en GamePanel el tipo de LevelController creado de FakeScrollLevel a CameraScrollLevel y dandole click en 'Run'!</p>
						
					</div>
					<div class="proj-content" id="pc-13">
						<h2 class="proj-sub-title">Camera Scrolling - Usos</h2>
						
						<p>Camera Scrolling es la contraparte de Fake Scrolling por lo que las ventajas de esta técnica cubren las desventajas de la anterior. Si se tiene un mundo o mapa extenso, con elementos en varios puntos del juego, se pueder renderizar todo el juego sin tomar en cuenta las ubicaciones de los elementos, ya que eventualmente la camara se moverá para renderizarlos en la pantalla. Por este motivo, esta técnica es la preferida cuando se hacen juegos de exploración o aventura o cualquier juego grande en 2D.</p>
						<br>
						<p>Desafortunadamente, hay un costo en rendimiento ya que se renderiza en cada momento TODO el juego completo y todos sus fondos. Esto puede hacer que tome un tiempo significativo si la cantidad de elementos es muy alta o el mapa y su fondo es muy grande. Se suele modificar para que solo se renderize aquello que esta dentro de los límites de la cámara, pero es implica una transformación grande a la estructura del proyecto, ya que se necesita implementar un Renderizador que sea selectivo y también una manera de búsqueda para retribuir en un tiempo eficiente los elementos del juego adentro de la vista de la cámara.</p>
						
					</div>
				</div>
				<div class="proj-buttons">
					<div><button class="btn back">Back</button></div>
					<div><button class="btn next">Next</button></div>
				</div>
			</div>
		</div>

		<div class="chapter" id="ch-5">
			<h3>References and Resources</h3>
			<div id="references-container">
				<h4>Links</h4>
				<ul>
					<li><a target="_blank" href="https://www.google.com/">https://www.google.com/</a></li>
				</ul>
			</div>
		</div>

		<div class="chapter" id="ch-6">
			<div class="ch-img ch-img-small">
				<div class="ch-caption">Good Luck.</div>
				<div id="ch-3-secretary"></div>
				<div id="ch-3-boss"></div>
			</div>
			<div class="ch-dialog">
				<p>Buena suerte!</p>
				<p>Te deseo lo mejor</p>
			</div>
		</div>

		<footer>
			Copyright 2019 - Juan José Olivera Loyola & Topiltzin Hernández Mares
		</footer>

	</main>

	<script type="text/javascript" src="main.js"></script>
	<script type="text/javascript" src="lab.js"></script>

</body>
</html>